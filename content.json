{"meta":{"title":"Liori's Blog","subtitle":"","description":"","author":"Liori","url":"https://liorima.github.io","root":"/"},"pages":[{"title":"about","date":"2019-12-25T14:18:13.000Z","updated":"2019-12-25T15:18:03.923Z","comments":true,"path":"about/index.html","permalink":"https://liorima.github.io/about/index.html","excerpt":"","text":"心再静些，静到一闭眼就能听到万物呼吸的声音。眉目舒展，将心胸也无限扩大，直到连天地也包得下。愿低调从容。"},{"title":"categories","date":"2019-12-25T15:24:57.000Z","updated":"2019-12-25T15:51:59.713Z","comments":true,"path":"categories/index.html","permalink":"https://liorima.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-12-25T15:25:06.000Z","updated":"2019-12-25T15:51:34.504Z","comments":true,"path":"friends/index.html","permalink":"https://liorima.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T15:24:48.000Z","updated":"2019-12-25T15:52:49.349Z","comments":true,"path":"tags/index.html","permalink":"https://liorima.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode】160-相交链表","slug":"LeetCode】160-相交链表","date":"2020-01-15T15:56:00.000Z","updated":"2020-01-15T15:58:48.667Z","comments":true,"path":"2020/01/15/LeetCode】160-相交链表/","link":"","permalink":"https://liorima.github.io/2020/01/15/LeetCode%E3%80%91160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"相交链表 题目编写一个程序，找到两个单链表相交的起始节点。 示例 1：输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。示例 3：输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。注意：如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路使用 2 个指针，分别遍历 headA，headB，每次前进 1 步。当一个链表遍历完时，从另一个链表的起始位置再次开始遍历。如果两个链表相交，则两个指针一定会相遇，相遇点即相交点。如果两个指针都已遍历完两个链表，且仍未相遇，则说明链表不相交。 代码12345678910111213141516class Solution { public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode l1 = headA; ListNode l2 = headB; while (l1 != l2) { // 如果l1、l2不相交，则实际上会遍历 l1.length + l2.length 次，最终 l1 == l2 == null l1 = l1 == null ? headB : l1.next; l2 = l2 == null ? headA : l2.next; } return l1; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】21-合并两个有序链表","slug":"eetCode】21-合并两个有序链表","date":"2020-01-14T15:09:00.000Z","updated":"2020-01-14T16:05:53.866Z","comments":true,"path":"2020/01/14/eetCode】21-合并两个有序链表/","link":"","permalink":"https://liorima.github.io/2020/01/14/eetCode%E3%80%9121-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"合并两个有序链表 题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 解法1：迭代法 解题思路需要注意的是，题目给的两个链表都是有序链表，因此同时遍历两个链表，逐一比较即可。当其中一个链表遍历完成时，另一个链表剩下的元素一定是大于当前链表的，将剩下的节点拼接到返回链表的尾部。 代码 1234567891011121314151617181920212223class Solution { /** * 迭代法 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // new一个虚拟头节点，这样while中就不需要再判断head是否为空 ListNode head = new ListNode(0); ListNode node = head; while (l1 != null && l2 != null) { if (l1.val < l2.val) { node.next = l1; l1 = l1.next; } else { node.next = l2; l2 = l2.next; } node = node.next; } // l1或l2中较大的那个链表可能还有剩余 node.next = l1 != null ? l1 : l2; return head.next; }} 递归法 解题思路思路与迭代法相似，只是实现方法不同。 代码 123456789101112131415161718class Solution { /** * 迭归法 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null || l2 == null) { return l1 != null ? l1 : l2; } if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】142-环形链表II","slug":"【LeetCode】142-环形链表II","date":"2020-01-13T15:08:00.000Z","updated":"2020-01-13T16:22:21.441Z","comments":true,"path":"2020/01/13/【LeetCode】142-环形链表II/","link":"","permalink":"https://liorima.github.io/2020/01/13/%E3%80%90LeetCode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/","excerpt":"","text":"环形链表II 题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。示例 1：输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。示例 2：输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。示例 3：输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。进阶：你是否可以不用额外空间解决此题？ 解题思路这道题目是 141 的进阶版，同样需要用到快慢指针，但要更复杂些。 如图，假设起点到入环点的距离为 a，顺时针方向入环点到相遇点的距离为 b，相遇点到入环点的距离为 c。则有： 慢指针走过的路程：a + b快指针走过的路程：a + b + n(b + c)（n 为圈数） 由于快指针速度是慢指针的 2 倍，故有： 2(a + b) = a + b + n(b + c) 公式可转化为： a + b = n(b + c) 进一步可转化为： a = n(b + c) - ba = n(b + c) - b - c + ca = (n - 1)(b + c) + c 即 a 的距离等于相遇点到入环点的距离 + n 圈的距离。 由此，我们可以在快慢指针相遇后，将快指针移动到头节点，慢指针在相遇点。快慢指针同时前进（每次前进 1 步），当快指针走完 a 距离时，慢指针刚好走好 c 距离 + n 圈的距离，它们相遇的地方就是入环点。 代码1234567891011121314151617181920212223242526class Solution { public ListNode detectCycle(ListNode head) { if (head == null || head.next == null) { return null; } ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; // 先找到相遇点 if (fast == slow) { fast = head; // 再找到入环点 while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } return null; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】141-环形链表","slug":"【LeetCode】141-环形链表-1","date":"2020-01-12T17:12:00.000Z","updated":"2020-01-12T17:47:21.297Z","comments":true,"path":"2020/01/13/【LeetCode】141-环形链表-1/","link":"","permalink":"https://liorima.github.io/2020/01/13/%E3%80%90LeetCode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-1/","excerpt":"","text":"环形链表 题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。示例 1:输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2:输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路这道题目可以用快慢指针解决。快指针每次走 2 步，慢指针每次走 1 步。如果快指针追上慢指针，则说明链表中存在环（就像 2 个人在操场上跑步，一个跑得快，一个跑得慢，跑得快的那个最终一定会追上慢的那个）。 代码1234567891011121314151617181920212223class Solution { /** * 使用快慢指针，快指针每次走2步，慢指针每次走1步，如果快指针追上了慢指针，则说明存在环 */ public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"}]}