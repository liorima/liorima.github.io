{"meta":{"title":"Liori's Blog","subtitle":"","description":"","author":"Liori","url":"https://liorima.github.io","root":"/"},"pages":[{"title":"about","date":"2019-12-25T14:18:13.000Z","updated":"2019-12-25T15:18:03.923Z","comments":true,"path":"about/index.html","permalink":"https://liorima.github.io/about/index.html","excerpt":"","text":"心再静些，静到一闭眼就能听到万物呼吸的声音。眉目舒展，将心胸也无限扩大，直到连天地也包得下。愿低调从容。"},{"title":"categories","date":"2019-12-25T15:24:57.000Z","updated":"2019-12-25T15:51:59.713Z","comments":true,"path":"categories/index.html","permalink":"https://liorima.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-12-25T15:25:06.000Z","updated":"2019-12-25T15:51:34.504Z","comments":true,"path":"friends/index.html","permalink":"https://liorima.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-25T15:24:48.000Z","updated":"2019-12-25T15:52:49.349Z","comments":true,"path":"tags/index.html","permalink":"https://liorima.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【LeetCode】101-对称二叉树","slug":"eetCode】101-对称二叉树","date":"2020-02-15T01:48:26.000Z","updated":"2020-02-15T02:25:54.729Z","comments":true,"path":"2020/02/15/eetCode】101-对称二叉树/","link":"","permalink":"https://liorima.github.io/2020/02/15/eetCode%E3%80%91101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","excerpt":"","text":"对称二叉树 题目给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的，但是这个 [1,2,2,null,3,null,3] 则不是镜像对称的。（示例图已省略，可点击顶部标题查看题目）说明:如果你可以运用递归和迭代两种方法解决这个问题，会很加分。 解法1：迭代法 解题思路迭代法的实现和层序遍历相似，只不过每次从队列中取出2个节点进行比较，且将这2个节点的左子节点、右子节点添加进队列，直到队列为空。需要注意的是，将节点添加进队列时需要注意添加顺序，左节点的左子节点和右节点的右子节点比较，左节点的右子节点比较和右节点的左子节点。 代码 12345678910111213141516171819202122232425262728293031323334class Solution { /** * 迭代法 */ public static boolean isSymmetric2(TreeNode root) { if (root == null) { return true; } Queue queue = new LinkedList(); queue.offer(root.left); queue.offer(root.right); while (!queue.isEmpty()) { TreeNode left = queue.poll(); TreeNode right = queue.poll(); // left==right==null，说明到了最后一层，进入下一次循环，直到队列为空 if (left == null && right == null) { continue; } // 这里的left和right不可以同时为null if (left == null || right == null || left.val != right.val) { return false; } queue.offer(left.left); queue.offer(right.right); queue.offer(left.right); queue.offer(right.left); } return true; }} 递归法 解题思路思路与迭代法相似，只是实现方法不同。 代码 12345678910111213141516171819202122232425class Solution { /** * 递归法 */ public static boolean isSymmetric(TreeNode root) { if (root == null) { return true; } return isSymmetric(root.left, root.right); } private static boolean isSymmetric(TreeNode left, TreeNode right) { if (left == null) { return right == null; } if (right == null) { return false; } if (left.val != right.val) { return false; } return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left); }}","categories":[],"tags":[],"author":"Liori"},{"title":"【LeetCode】237-删除链表中的节点","slug":"【LeetCode】237-删除链表中的节点","date":"2020-01-16T15:44:00.000Z","updated":"2020-01-16T15:48:08.137Z","comments":true,"path":"2020/01/16/【LeetCode】237-删除链表中的节点/","link":"","permalink":"https://liorima.github.io/2020/01/16/%E3%80%90LeetCode%E3%80%91237-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","excerpt":"","text":"删除链表中的节点 题目请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例 1:输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.示例 2:输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9.说明:链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。 解题思路这道题目实在是有些坑，看完描述心中呵呵，一个 for 循环找到待删除的节点，再将待删除的节点的上一节点的 next 指向待删除节点的下一节点，这不就搞定了吗，简单！一看代码，怎么入参只有一个啊，懵圏半天。 这就是这道题目需要注意的一个地方，实际上入参只有一个待删除节点的引用，也就是说，我们不知道待删除节点的上一个节点，也就无法将它的 next 指向待删除节点的下一节点。 问题不大，换个思路就是。 既然我们拿到的是待删除节点的引用，也就是说，待删除节点及其后面关联的节点，我们都有。此外题目中还指明待删除节点是一个非末尾结点、链表至少包含两个节点。 假设我们拿到的待删除节点是 4->5->6，我们要删除 4，那么只要用待删除节点的后一个节点的值覆盖待删除节点（此时变成5->5->6）,再将待删除节点的 next 指向待删除节点的后一个节点的后一个节点即可（即 4 的 next 指向 6，此时变成 5->6, 5）。 代码123456class Solution { public void deleteNode(ListNode node) { node.val = node.next.val; node.next = node.next.next; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】160-相交链表","slug":"LeetCode】160-相交链表","date":"2020-01-15T15:56:00.000Z","updated":"2020-01-15T15:58:48.667Z","comments":true,"path":"2020/01/15/LeetCode】160-相交链表/","link":"","permalink":"https://liorima.github.io/2020/01/15/LeetCode%E3%80%91160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","excerpt":"","text":"相交链表 题目编写一个程序，找到两个单链表相交的起始节点。 示例 1：输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。示例 2：输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。示例 3：输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。注意：如果两个链表没有交点，返回 null.在返回结果后，两个链表仍须保持原有的结构。可假定整个链表结构中没有循环。程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 解题思路使用 2 个指针，分别遍历 headA，headB，每次前进 1 步。当一个链表遍历完时，从另一个链表的起始位置再次开始遍历。如果两个链表相交，则两个指针一定会相遇，相遇点即相交点。如果两个指针都已遍历完两个链表，且仍未相遇，则说明链表不相交。 代码12345678910111213141516class Solution { public static ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode l1 = headA; ListNode l2 = headB; while (l1 != l2) { // 如果l1、l2不相交，则实际上会遍历 l1.length + l2.length 次，最终 l1 == l2 == null l1 = l1 == null ? headB : l1.next; l2 = l2 == null ? headA : l2.next; } return l1; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】21-合并两个有序链表","slug":"eetCode】21-合并两个有序链表","date":"2020-01-14T15:09:00.000Z","updated":"2020-01-14T16:05:53.866Z","comments":true,"path":"2020/01/14/eetCode】21-合并两个有序链表/","link":"","permalink":"https://liorima.github.io/2020/01/14/eetCode%E3%80%9121-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","excerpt":"","text":"合并两个有序链表 题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1->2->4, 1->3->4 输出：1->1->2->3->4->4 解法1：迭代法 解题思路需要注意的是，题目给的两个链表都是有序链表，因此同时遍历两个链表，逐一比较即可。当其中一个链表遍历完成时，另一个链表剩下的元素一定是大于当前链表的，将剩下的节点拼接到返回链表的尾部。 代码 1234567891011121314151617181920212223class Solution { /** * 迭代法 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // new一个虚拟头节点，这样while中就不需要再判断head是否为空 ListNode head = new ListNode(0); ListNode node = head; while (l1 != null && l2 != null) { if (l1.val < l2.val) { node.next = l1; l1 = l1.next; } else { node.next = l2; l2 = l2.next; } node = node.next; } // l1或l2中较大的那个链表可能还有剩余 node.next = l1 != null ? l1 : l2; return head.next; }} 递归法 解题思路思路与迭代法相似，只是实现方法不同。 代码 123456789101112131415161718class Solution { /** * 迭归法 */ public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if (l1 == null || l2 == null) { return l1 != null ? l1 : l2; } if (l1.val < l2.val) { l1.next = mergeTwoLists(l1.next, l2); return l1; } else { l2.next = mergeTwoLists(l1, l2.next); return l2; } }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】142-环形链表II","slug":"【LeetCode】142-环形链表II","date":"2020-01-13T15:08:00.000Z","updated":"2020-01-13T16:22:21.441Z","comments":true,"path":"2020/01/13/【LeetCode】142-环形链表II/","link":"","permalink":"https://liorima.github.io/2020/01/13/%E3%80%90LeetCode%E3%80%91142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II/","excerpt":"","text":"环形链表II 题目给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。说明：不允许修改给定的链表。示例 1：输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。示例 2：输入：head = [1,2], pos = 0输出：tail connects to node index 0解释：链表中有一个环，其尾部连接到第一个节点。示例 3：输入：head = [1], pos = -1输出：no cycle解释：链表中没有环。进阶：你是否可以不用额外空间解决此题？ 解题思路这道题目是 141 的进阶版，同样需要用到快慢指针，但要更复杂些。 如图，假设起点到入环点的距离为 a，顺时针方向入环点到相遇点的距离为 b，相遇点到入环点的距离为 c。则有： 慢指针走过的路程：a + b快指针走过的路程：a + b + n(b + c)（n 为圈数） 由于快指针速度是慢指针的 2 倍，故有： 2(a + b) = a + b + n(b + c) 公式可转化为： a + b = n(b + c) 进一步可转化为： a = n(b + c) - ba = n(b + c) - b - c + ca = (n - 1)(b + c) + c 即 a 的距离等于相遇点到入环点的距离 + n 圈的距离。 由此，我们可以在快慢指针相遇后，将快指针移动到头节点，慢指针在相遇点。快慢指针同时前进（每次前进 1 步），当快指针走完 a 距离时，慢指针刚好走好 c 距离 + n 圈的距离，它们相遇的地方就是入环点。 代码1234567891011121314151617181920212223242526class Solution { public ListNode detectCycle(ListNode head) { if (head == null || head.next == null) { return null; } ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; // 先找到相遇点 if (fast == slow) { fast = head; // 再找到入环点 while (fast != slow) { fast = fast.next; slow = slow.next; } return slow; } } return null; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"},{"title":"【LeetCode】141-环形链表","slug":"【LeetCode】141-环形链表-1","date":"2020-01-12T17:12:00.000Z","updated":"2020-01-12T17:47:21.297Z","comments":true,"path":"2020/01/13/【LeetCode】141-环形链表-1/","link":"","permalink":"https://liorima.github.io/2020/01/13/%E3%80%90LeetCode%E3%80%91141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-1/","excerpt":"","text":"环形链表 题目给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。示例 1:输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。示例 2:输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3：输入：head = [1], pos = -1输出：false解释：链表中没有环。进阶：你能用 O(1)（即，常量）内存解决此问题吗？ 解题思路这道题目可以用快慢指针解决。快指针每次走 2 步，慢指针每次走 1 步。如果快指针追上慢指针，则说明链表中存在环（就像 2 个人在操场上跑步，一个跑得快，一个跑得慢，跑得快的那个最终一定会追上慢的那个）。 代码1234567891011121314151617181920212223class Solution { /** * 使用快慢指针，快指针每次走2步，慢指针每次走1步，如果快指针追上了慢指针，则说明存在环 */ public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode fast = head; ListNode slow = head; while (fast != null && fast.next != null) { fast = fast.next.next; slow = slow.next; if (fast == slow) { return true; } } return false; }}","categories":[{"name":"Code","slug":"Code","permalink":"https://liorima.github.io/categories/Code/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://liorima.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://liorima.github.io/tags/LeetCode/"}],"author":"Liori"}]}